#!/usr/bin/env python

import os, sys, codecs, string, glob
import plasTeX
from plasTeX.TeX import TeX
from plasTeX.Logging import getLogger
import pdb
from plasTeX.Config import config
from plasTeX.ConfigManager import *

log = getLogger()

def main(argv):
	""" Main program routine """

	try:
		opts, args = config.getopt(argv)
	except Exception, msg:
		log.error(msg)
		print >>sys.stderr, config.usage()
		sys.exit(1)

	if not args:
		print >>sys.stderr, config.usage()
		sys.exit(1)


	file = args.pop(0)

	outFormat = 'xml'

	if args:
		outFormat = args.pop(0)


	# Create document instance that output will be put into
	document = plasTeX.TeXDocument(config=config)

	# Instantiate the TeX processor
	tex = TeX(document, file=file)

	# Populate variables for use later
	jobname = document.userdata['jobname'] = tex.jobname
	cwd = document.userdata['working-dir'] = os.getcwd()

	# Load aux files for cross-document references
#	pauxname = '%s.paux' % jobname

	# for dirname in [cwd] + config['general']['paux-dirs']:
	# 	for fname in glob.glob(os.path.join(dirname, '*.paux')):
	# 		if os.path.basename(fname) == pauxname:
	# 			continue
	# 		document.context.restore(fname, rname)

	# Parse the document
	tex.parse()


	# Set up TEXINPUTS to include the current directory for the renderer
	os.environ['TEXINPUTS'] = '%s%s%s%s' % (os.getcwd(), os.pathsep,
										 os.environ.get('TEXINPUTS',''), os.pathsep)

	 # Change to specified directory to output to
	outdir = document.config['files']['directory']
	if outdir:
		outdir = string.Template(outdir).substitute({'jobname':jobname})
		if not os.path.isdir(outdir):
			os.makedirs(outdir)
		log.info('Directing output files to directory: %s.' % outdir)
		os.chdir(outdir)

	mathml = outFormat == 'mathml'
	transform( document, mathml )

	if outFormat == 'images':
		db = generateImages(document)


	if outFormat == 'xhtml':
		document.config['files']['split-level'] = 0
		render( document, jobname, 'XHTML' )

	if outFormat == 'xml' or mathml:
		toXml( document, jobname )



def render(document, jobname, rname):
    # Load renderer
    try:
        exec('from plasTeX.Renderers.%s import Renderer' % rname)
    except ImportError, msg:
        log.error('Could not import renderer "%s".  Make sure that it is installed correctly, and can be imported by Python.' % rname)
        sys.exit(1)

    # Apply renderer
    Renderer().render(document)

def toXml( document, jobname ):
	outfile = '%s.xml' % jobname
	with open(outfile,'w') as f: f.write(document.toXML().encode('utf-8'))

import string

def transform( document, mathml=False ):
	""" Applies DOM transformations to the document. """

	class _mathnode(plasTeX.Base.Command):
		resourceTypes=['mathml','svg']

		@property
		def source(self):
			return self.origMathSource

		def toXML(self):
			return "<%s expr='%s' />" % (self.nodeName, self.expr)

	class mathangle(_mathnode):
		nodeName = 'mathangle'

	class mathline(_mathnode):
		resourceTypes=['svg']
		nodeName = 'mathline'

	class mathname(_mathnode):
		nodeName = 'mathname'

	document.context['mathangle'] = mathangle
	document.context['mathname'] = mathname
	document.context['mathline'] = mathline

	# Remove unneeded math elements ($24$) and add semantic
	# information where we can infer it from the text
	# ("angle $AB" => <mathangle 'AB'>)
	for math in document.getElementsByTagName( 'math' ):
		try:
			text = math.textContent
			if not(text):
				print 'Found empty math node'
			elif all( [c in string.ascii_letters for c in text] ):
				r = None

				if math.previousSibling:
					prevText = (math.previousSibling.textContent or '').rstrip()
					if prevText.lower().endswith( ' angle' ):
						r = document.createElement( 'mathangle' )
					elif prevText.lower().endswith( ' line') or prevText == 'Line':
						r = document.createElement( 'mathline' )
				if r is None:
					r = document.createElement( 'mathname' )
				r.expr = text
				r.origMathSource=math.source
				math.parentNode.replaceChild( r, math )

			else:
				float(math.textContent)
				oldparent = math.parentNode
				math.parentNode.replaceChild( text, math )
				oldparent.normalize()

		except UnicodeEncodeError, e:
			pass
		except ValueError, e:
			pass
		except plasTeX.DOM.NotFoundErr, e:
			print 'Unable to replace ', math.textContent
			import traceback
			traceback.print_exc()

	# Transform the remaining plastex math elements to mathml
	if mathml:
		transform2mathml(document)

	# Chapterauthor and chapterquote need to move down a level, inside
	# their respective chapters. NOTE: They use the same
	# macros for the book quote, the first one, which we want to leave alone.
	for chapterquote in document.getElementsByTagName( 'chapterquote')[1:]:
		chapterauthor = chapterquote.parentNode.getElementsByTagName( 'chapterauthor' )[0]
		parent = chapterquote.parentNode
		# move it up out of containing par and raggedbottom, etc
		while parent:
			if parent.nextSibling and parent.nextSibling.nodeName == 'chapter':
				break
			parent = parent.parentNode

		if parent and parent.nextSibling:
			chapterquote.parentNode.removeChild( chapterauthor )
			chapterquote.parentNode.removeChild( chapterquote )
			parent.nextSibling.insert( 0, chapterquote )
			parent.nextSibling.insert( 1, chapterauthor )

from plastex2mathml import plastex2mathml

def transform2mathml(document):
	mathmlTransform = plastex2mathml()

	mathmlTransform.transform(document)

from resources import ResourceDB

def generateImages(document):
	### Generates required images ###

	db = ResourceDB(document)

	return db;



if __name__ == '__main__':
	main(sys.argv[1:])
