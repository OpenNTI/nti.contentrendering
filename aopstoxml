#!/usr/bin/env python

import os, sys, codecs, string, glob
import plasTeX
from plasTeX.TeX import TeX
from plasTeX.Logging import getLogger
import pdb
from plasTeX.ConfigManager import *

log = getLogger()

def main(argv):
	""" Main program routine """


	file = argv.pop(0)

	outFormat = 'xml'

	if argv:
		outFormat = argv.pop(0)

	#Use transperant images


	# Create document instance that output will be put into
	document = plasTeX.TeXDocument()
	#setup config options we want
	document.config['files']['split-level']=1
	document.config['general']['theme']='AoPS'

	# Instantiate the TeX processor
	tex = TeX(document, file=file)

	# Populate variables for use later
	jobname = document.userdata['jobname'] = tex.jobname
	cwd = document.userdata['working-dir'] = os.getcwd()



	# Load aux files for cross-document references
#	pauxname = '%s.paux' % jobname

	# for dirname in [cwd] + config['general']['paux-dirs']:
	#	for fname in glob.glob(os.path.join(dirname, '*.paux')):
	#		if os.path.basename(fname) == pauxname:
	#			continue
	#		document.context.restore(fname, rname)

	# Parse the document
	tex.parse()


	# Set up TEXINPUTS to include the current directory for the renderer
	os.environ['TEXINPUTS'] = '%s%s%s%s' % (os.getcwd(), os.pathsep,
										 os.environ.get('TEXINPUTS',''), os.pathsep)

	 # Change to specified directory to output to
	outdir = document.config['files']['directory']
	if outdir:
		outdir = string.Template(outdir).substitute({'jobname':jobname})
		if not os.path.isdir(outdir):
			os.makedirs(outdir)
		log.info('Directing output files to directory: %s.' % outdir)
		os.chdir(outdir)

	mathml = outFormat == 'mathml'
	transform( document, mathml )



	if outFormat == 'images' or outFormat == 'xhtml':
		db = generateImages(document)



	if outFormat == 'xhtml':
		render( document, jobname, 'XHTML', db )

	if outFormat == 'xml' or mathml:
		toXml( document, jobname )



def render(document, jobname, rname, db):


	plasTeX.Renderers.Renderer.render=renderDocument
	plasTeX.Renderers.Renderer.renderableClass=Renderable
	# Load renderer
	try:
		exec('from plasTeX.Renderers.%s import Renderer' % rname)
	except ImportError, msg:
		log.error('Could not import renderer "%s".	Make sure that it is installed correctly, and can be imported by Python.' % rname)
		sys.exit(1)



	# Apply renderer
	renderer = Renderer()
	renderer.resourcedb=db
	renderer.render(document)

def toXml( document, jobname ):
	outfile = '%s.xml' % jobname
	with open(outfile,'w') as f: f.write(document.toXML().encode('utf-8'))

import string

def transform( document, mathml=False ):
	""" Applies DOM transformations to the document. """

	class _mathnode(plasTeX.Base.Command):
		resourceTypes=['mathml','svg']

		@property
		def source(self):
			return self.origMathSource

		def toXML(self):
			return "<%s expr='%s' />" % (self.nodeName, self.expr)

	class mathangle(_mathnode):
		nodeName = 'mathangle'

	class mathline(_mathnode):
		resourceTypes=['svg']
		nodeName = 'mathline'

	class mathname(_mathnode):
		nodeName = 'mathname'

	document.context['mathangle'] = mathangle
	document.context['mathname'] = mathname
	document.context['mathline'] = mathline

	# Remove unneeded math elements ($24$) and add semantic
	# information where we can infer it from the text
	# ("angle $AB" => <mathangle 'AB'>)
	for math in document.getElementsByTagName( 'math' ):
		try:
			text = math.textContent
			if not(text):
				print 'Found empty math node'
			elif all( [c in string.ascii_letters for c in text] ):
				r = None

				if math.previousSibling:
					prevText = (math.previousSibling.textContent or '').rstrip()
					if prevText.lower().endswith( ' angle' ):
						r = document.createElement( 'mathangle' )
					elif prevText.lower().endswith( ' line') or prevText == 'Line':
						r = document.createElement( 'mathline' )
				if r is None:
					r = document.createElement( 'mathname' )
				r.expr = text
				r.origMathSource=math.source
				math.parentNode.replaceChild( r, math )

			else:
				float(math.textContent)
				oldparent = math.parentNode
				math.parentNode.replaceChild( text, math )
				oldparent.normalize()

		except UnicodeEncodeError, e:
			pass
		except ValueError, e:
			pass
		except plasTeX.DOM.NotFoundErr, e:
			print 'Unable to replace ', math.textContent
			import traceback
			traceback.print_exc()

	# Transform the remaining plastex math elements to mathml
	if mathml:
		transform2mathml(document)

	# Chapterauthor and chapterquote need to move down a level, inside
	# their respective chapters. NOTE: They use the same
	# macros for the book quote, the first one, which we want to leave alone.
	for chapterquote in document.getElementsByTagName( 'chapterquote')[1:]:
		chapterauthor = chapterquote.parentNode.getElementsByTagName( 'chapterauthor' )[0]
		parent = chapterquote.parentNode
		# move it up out of containing par and raggedbottom, etc
		while parent:
			if parent.nextSibling and parent.nextSibling.nodeName == 'chapter':
				break
			parent = parent.parentNode

		if parent and parent.nextSibling:
			chapterquote.parentNode.removeChild( chapterauthor )
			chapterquote.parentNode.removeChild( chapterquote )
			parent.nextSibling.insert( 0, chapterquote )
			parent.nextSibling.insert( 1, chapterauthor )

from plastex2mathml import plastex2mathml

def transform2mathml(document):
	mathmlTransform = plastex2mathml()

	mathmlTransform.transform(document)

from resources import ResourceDB

def generateImages(document):
	### Generates required images ###

	db = ResourceDB(document)
	db.generateResourceSets()

	return db;

from plasTeX.Renderers import mixin, unmix, baseclasses
from plasTeX.DOM import Node
from plasTeX.Filenames import Filenames

def renderDocument(self, document, postProcess=None):
	"""
	Invoke the rendering process

	This method invokes the rendering process as well as handling
	the setup and shutdown of image processing.

	Required Arguments:
	document -- the document object to render
	postProcess -- a function that will be called with the content of

	"""
	config = document.config

	# If there are no keys, print a warning.
	# This is most likely a problem.
	if not self.keys():
		log.warning('There are no keys in the renderer.	 ' +
					'All objects will use the default rendering method.')

	# Mix in required methods and members
	mixin(Node, type(self).renderableClass)
	Node.renderer = self

	# Create a filename generator
	self.newFilename = Filenames(config['files'].get('filename', raw=True),
								 (config['files']['bad-chars'],
								  config['files']['bad-chars-sub']),
								 {'jobname':document.userdata.get('jobname', '')}, self.fileExtension)

	self.cacheFilenames(document)



	# Invoke the rendering process
	if type(self).renderMethod:
		getattr(document, type(self).renderMethod)()
	else:
		unicode(document)


	# Run any cleanup activities
	self.cleanup(document, self.files.values(), postProcess=postProcess)

	# Write out auxilliary information
	pauxname = os.path.join(document.userdata.get('working-dir','.'),
							'%s.paux' % document.userdata.get('jobname',''))
	rname = config['general']['renderer']
	document.context.persist(pauxname, rname)

	# Remove mixins
	del Node.renderer
	unmix(Node, type(self).renderableClass)


from plasTeX.Renderers import Renderable as BaseRenderable

class Renderable(BaseRenderable):


	@property
	def image(self):


		return self.getResource(['png', 'orig', 1])

	@property
	def vectorImage(self):
		return self.getResource(['svg'])


	def contents(self, criteria):
		return self.renderer.resourcedb.contentsAsString(self.getResource(criteria))

	def getResource(self, criteria):
		rs = self.getResourceSet()

		resource=None

		if rs:
			try:
				resources=rs.resources
				for crit in criteria:
					resources=resources[crit]

				resource=resources
			except KeyError:
				log.warning('resource for criteria %s does not exist for node %s'%(criteria, self))
				return None
		return resource


	def getResourceSet(self):
		return Node.renderer.resourcedb.getResourceSet(self)

if __name__ == '__main__':
	main(sys.argv[1:])
